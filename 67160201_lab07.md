# บันทึกความเข้าใจปฏิบัติการที่ 7

## 1.6 ตอบคำถามเพื่อวัดความเข้าใจ (Activity 1)

### 1. querySelector vs querySelectorAll: อะไรคือความแตกต่าง

querySelector(): ใช้เมื่อต้องการเลือก Element แรกเพียงตัวเดียว ที่ตรงกับ Selector ที่ระบุ (คืนค่าเป็น Object)

querySelectorAll(): ใช้เมื่อต้องการเลือก ทุก Element ที่ตรงกับ Selector นั้น ๆ (คืนค่าเป็น NodeList ซึ่งต้องใช้ Loop ในการจัดการ)

### 2. classList.toggle(): nav.classList.toggle('hidden') ทำงานอย่างไร

ถ้า nav มี class 'hidden' อยู่แล้ว: toggle() จะทำการ ลบ (remove) class นั้นออก

ถ้า nav ไม่มี class 'hidden': toggle() จะทำการ เพิ่ม (add) class นั้นเข้าไป

### 3. event.target: เมื่อคลิกปุ่ม event.target จะชี้ไปที่อะไร

ชี้ไปที่ Element ที่ถูกคลิกจริงๆ (ในที่นี้คือ Element ปุ่มที่ผู้ใช้กด)

### 4. remove() vs toggle(): เมื่อคลิก link ควรใช้แบบไหน?

ควรใช้ nav.classList.remove('hidden') หากเราต้องการให้เมนูปิดลงทันทีเมื่อเลือกเมนู (เจาะจงการกระทำเดียว) แต่ถ้าต้องการให้ปุ่มเดียวทำหน้าที่ทั้งเปิดและปิด (เช่น ปุ่ม Hamburger) ควรใช้ toggle()

### 5. display: none: .hidden { display: none; } ทำไมจึงจำเป็น?

ความจำเป็น: เพื่อทำให้ Element นั้นหายไปจากหน้าจอและไม่กินพื้นที่ในการจัด Layout

วิธีอื่น: สามารถใช้ opacity: 0 (ซ่อนแต่ยังกินพื้นที่), visibility: hidden (ซ่อนแต่ยังกินพื้นที่) หรือใช้การปรับตำแหน่งให้หลุดออกนอกหน้าจอ (เช่น left: -9999px)

---

## 2.6 ตอบคำถามเพื่อวัดความเข้าใจ (Activity 2)

### 1. Event Delegation: ทำไมเราต้องใช้สำหรับ todo list?

เพราะ Todo list มีการเพิ่ม Element ใหม่ๆ (dynamic elements) ตลอดเวลา การผูก Event ไว้ที่ Parent เพียงตัวเดียวช่วยให้ปุ่มที่เกิดขึ้นใหม่ใช้งานได้ทันทีโดยไม่ต้องเขียน code ผูก Event ซ้ำทุกครั้ง

### 2. event.target ใน event delegation ชี้ไปที่อะไร?

ชี้ไปที่ Element ที่ถูกคลิกจริง ๆ (เช่น ปุ่ม Delete ภายใน <li>) ไม่ใช่ตัว Parent ที่ถือ Listener

### 3. innerHTML vs textContent: ทำไมต้องใช้ innerHTML?

เพราะเราต้องการสร้างโครงสร้าง HTML ภายในลิสต์ (เช่น ใส่แท็ก span สำหรับข้อความ และ button สำหรับปุ่มลบ) ซึ่ง textContent จะมองทุกอย่างเป็นข้อความธรรมดาและไม่ render แท็ก HTML

### 4. New Elements: ถ้าเพิ่ม todo ใหม่ ปุ่ม delete ยังใช้งานได้ไหม?

ใช้งานได้ เพราะเราใช้ Event Delegation โดยดักจับเหตุการณ์ที่ Parent (ul) ซึ่งมีตัวตนอยู่แล้วตั้งแต่โหลดหน้าเว็บ

### 5. if (!text) return: Code นี้ทำไม?

เป็นการตรวจสอบค่าว่าง (Validation) ถ้าผู้ใช้ไม่พิมพ์อะไรเลย (Empty string) ฟังก์ชันจะหยุดทำงานทันที (return) เพื่อไม่ให้เพิ่ม Todo ว่างๆ ลงในรายการ

### 6. trim(): ทำไมต้องใช้ก่อนตรวจสอบ?

เพื่อตัดช่องว่าง (Whitespace) ที่อยู่หน้าและหลังข้อความออก ป้องกันกรณีผู้ใช้เคาะ Spacebar รัวๆ แล้วกดเพิ่มข้อมูล

---

## 3.6 ตอบคำถามเพื่อวัดความเข้าใจ (Activity 3)

### 1. 'input' vs 'change' event: ต่างกันอย่างไร?

input: ทำงานทันทีที่ตัวอักษรมีการเปลี่ยนแปลง (Real-time) เหมาะสำหรับ validation ที่ต้องการสะท้อนผลทันที

change: ทำงานเมื่อ Element เสีย focus หรือผู้ใช้กด Enter หลังจากแก้ไขค่าเสร็จแล้ว

### 2. preventDefault(): ทำอะไร?

ใช้สำหรับยกเลิกพฤติกรรมเริ่มต้นของ Browser (Default behavior) เช่น การกดปุ่ม Submit ใน Form แล้วหน้าเว็บ Refresh ใหม่ เราใช้คำสั่งนี้เพื่อประมวลผลผ่าน JavaScript แทน

### 3. classList operations: ทำไมต้อง remove('error') และ add('valid') ทั้งคู่?

เพื่อให้สถานะของ Element ถูกต้องเพียงสถานะเดียว หากไม่ remove ค่าเก่าออก Element นั้นอาจจะถือทั้งสอง Class พร้อมกัน ทำให้การแสดงผลผิดพลาด

### 4. disabled attribute: submitBtn.disabled = true หมายถึงอะไร?

หมายถึงปุ่มถูก ปิดการใช้งาน (คลิกไม่ได้/เป็นสีเทา) สามารถจัดการผ่าน JavaScript ได้โดยการเปลี่ยนค่า boolean (true/false)

### 5. Email validation: กรณีไหนจะผิด

"user@gmail..com": ผ่าน (ใน logic พื้นฐานที่เช็คแค่การมี @ และ .) แต่มักจะผิดในแง่ของ Email Format จริงๆ

"user.gmail.com": ไม่ผ่าน เพราะไม่มีเครื่องหมาย @

### 6. DRY principle: ทำไมการเพิ่ม listener 4 ครั้งทำให้ code ยาว?

เพราะเกิดการเขียน Code ซ้ำซ้อน (Redundancy) หากมีการเปลี่ยนแปลง Logic การตรวจสอบ เราต้องตามไปแก้ทั้ง 4 จุด ซึ่งเสี่ยงต่อการเกิด Bug และดูแลรักษายาก

### 7. confirm-password field: ทำไมต้องมี?

เพื่อยืนยันว่าผู้ใช้พิมพ์รหัสผ่านถูกต้องตามที่ตั้งใจไว้จริงๆ ป้องกันการพิมพ์ผิด (Typo) ซึ่งจะทำให้เข้าสู่ระบบไม่ได้ในภายหลัง
